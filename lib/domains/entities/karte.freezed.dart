// dart format width=80
// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'karte.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

// dart format off
T _$identity<T>(T value) => value;

/// @nodoc
mixin _$UserAnalysis {
  String? get philosophyOnLove;
  String? get potentialNeeds;
  String? get compatibilityFeatures;
  String? get comprehensiveAnalysis;
  DateTime? get createdAt;

  /// Create a copy of UserAnalysis
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $UserAnalysisCopyWith<UserAnalysis> get copyWith =>
      _$UserAnalysisCopyWithImpl<UserAnalysis>(
          this as UserAnalysis, _$identity);

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is UserAnalysis &&
            (identical(other.philosophyOnLove, philosophyOnLove) ||
                other.philosophyOnLove == philosophyOnLove) &&
            (identical(other.potentialNeeds, potentialNeeds) ||
                other.potentialNeeds == potentialNeeds) &&
            (identical(other.compatibilityFeatures, compatibilityFeatures) ||
                other.compatibilityFeatures == compatibilityFeatures) &&
            (identical(other.comprehensiveAnalysis, comprehensiveAnalysis) ||
                other.comprehensiveAnalysis == comprehensiveAnalysis) &&
            (identical(other.createdAt, createdAt) ||
                other.createdAt == createdAt));
  }

  @override
  int get hashCode => Object.hash(runtimeType, philosophyOnLove, potentialNeeds,
      compatibilityFeatures, comprehensiveAnalysis, createdAt);

  @override
  String toString() {
    return 'UserAnalysis(philosophyOnLove: $philosophyOnLove, potentialNeeds: $potentialNeeds, compatibilityFeatures: $compatibilityFeatures, comprehensiveAnalysis: $comprehensiveAnalysis, createdAt: $createdAt)';
  }
}

/// @nodoc
abstract mixin class $UserAnalysisCopyWith<$Res> {
  factory $UserAnalysisCopyWith(
          UserAnalysis value, $Res Function(UserAnalysis) _then) =
      _$UserAnalysisCopyWithImpl;
  @useResult
  $Res call(
      {String? philosophyOnLove,
      String? potentialNeeds,
      String? compatibilityFeatures,
      String? comprehensiveAnalysis,
      DateTime? createdAt});
}

/// @nodoc
class _$UserAnalysisCopyWithImpl<$Res> implements $UserAnalysisCopyWith<$Res> {
  _$UserAnalysisCopyWithImpl(this._self, this._then);

  final UserAnalysis _self;
  final $Res Function(UserAnalysis) _then;

  /// Create a copy of UserAnalysis
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? philosophyOnLove = freezed,
    Object? potentialNeeds = freezed,
    Object? compatibilityFeatures = freezed,
    Object? comprehensiveAnalysis = freezed,
    Object? createdAt = freezed,
  }) {
    return _then(_self.copyWith(
      philosophyOnLove: freezed == philosophyOnLove
          ? _self.philosophyOnLove
          : philosophyOnLove // ignore: cast_nullable_to_non_nullable
              as String?,
      potentialNeeds: freezed == potentialNeeds
          ? _self.potentialNeeds
          : potentialNeeds // ignore: cast_nullable_to_non_nullable
              as String?,
      compatibilityFeatures: freezed == compatibilityFeatures
          ? _self.compatibilityFeatures
          : compatibilityFeatures // ignore: cast_nullable_to_non_nullable
              as String?,
      comprehensiveAnalysis: freezed == comprehensiveAnalysis
          ? _self.comprehensiveAnalysis
          : comprehensiveAnalysis // ignore: cast_nullable_to_non_nullable
              as String?,
      createdAt: freezed == createdAt
          ? _self.createdAt
          : createdAt // ignore: cast_nullable_to_non_nullable
              as DateTime?,
    ));
  }
}

/// @nodoc

class _UserAnalysis implements UserAnalysis {
  const _UserAnalysis(
      {required this.philosophyOnLove,
      required this.potentialNeeds,
      required this.compatibilityFeatures,
      required this.comprehensiveAnalysis,
      required this.createdAt});

  @override
  final String? philosophyOnLove;
  @override
  final String? potentialNeeds;
  @override
  final String? compatibilityFeatures;
  @override
  final String? comprehensiveAnalysis;
  @override
  final DateTime? createdAt;

  /// Create a copy of UserAnalysis
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$UserAnalysisCopyWith<_UserAnalysis> get copyWith =>
      __$UserAnalysisCopyWithImpl<_UserAnalysis>(this, _$identity);

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _UserAnalysis &&
            (identical(other.philosophyOnLove, philosophyOnLove) ||
                other.philosophyOnLove == philosophyOnLove) &&
            (identical(other.potentialNeeds, potentialNeeds) ||
                other.potentialNeeds == potentialNeeds) &&
            (identical(other.compatibilityFeatures, compatibilityFeatures) ||
                other.compatibilityFeatures == compatibilityFeatures) &&
            (identical(other.comprehensiveAnalysis, comprehensiveAnalysis) ||
                other.comprehensiveAnalysis == comprehensiveAnalysis) &&
            (identical(other.createdAt, createdAt) ||
                other.createdAt == createdAt));
  }

  @override
  int get hashCode => Object.hash(runtimeType, philosophyOnLove, potentialNeeds,
      compatibilityFeatures, comprehensiveAnalysis, createdAt);

  @override
  String toString() {
    return 'UserAnalysis(philosophyOnLove: $philosophyOnLove, potentialNeeds: $potentialNeeds, compatibilityFeatures: $compatibilityFeatures, comprehensiveAnalysis: $comprehensiveAnalysis, createdAt: $createdAt)';
  }
}

/// @nodoc
abstract mixin class _$UserAnalysisCopyWith<$Res>
    implements $UserAnalysisCopyWith<$Res> {
  factory _$UserAnalysisCopyWith(
          _UserAnalysis value, $Res Function(_UserAnalysis) _then) =
      __$UserAnalysisCopyWithImpl;
  @override
  @useResult
  $Res call(
      {String? philosophyOnLove,
      String? potentialNeeds,
      String? compatibilityFeatures,
      String? comprehensiveAnalysis,
      DateTime? createdAt});
}

/// @nodoc
class __$UserAnalysisCopyWithImpl<$Res>
    implements _$UserAnalysisCopyWith<$Res> {
  __$UserAnalysisCopyWithImpl(this._self, this._then);

  final _UserAnalysis _self;
  final $Res Function(_UserAnalysis) _then;

  /// Create a copy of UserAnalysis
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? philosophyOnLove = freezed,
    Object? potentialNeeds = freezed,
    Object? compatibilityFeatures = freezed,
    Object? comprehensiveAnalysis = freezed,
    Object? createdAt = freezed,
  }) {
    return _then(_UserAnalysis(
      philosophyOnLove: freezed == philosophyOnLove
          ? _self.philosophyOnLove
          : philosophyOnLove // ignore: cast_nullable_to_non_nullable
              as String?,
      potentialNeeds: freezed == potentialNeeds
          ? _self.potentialNeeds
          : potentialNeeds // ignore: cast_nullable_to_non_nullable
              as String?,
      compatibilityFeatures: freezed == compatibilityFeatures
          ? _self.compatibilityFeatures
          : compatibilityFeatures // ignore: cast_nullable_to_non_nullable
              as String?,
      comprehensiveAnalysis: freezed == comprehensiveAnalysis
          ? _self.comprehensiveAnalysis
          : comprehensiveAnalysis // ignore: cast_nullable_to_non_nullable
              as String?,
      createdAt: freezed == createdAt
          ? _self.createdAt
          : createdAt // ignore: cast_nullable_to_non_nullable
              as DateTime?,
    ));
  }
}

/// @nodoc
mixin _$Karte {
  List<UserAnalysis> get userAnalyses;
  String? get nextCursor;

  /// Create a copy of Karte
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $KarteCopyWith<Karte> get copyWith =>
      _$KarteCopyWithImpl<Karte>(this as Karte, _$identity);

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is Karte &&
            const DeepCollectionEquality()
                .equals(other.userAnalyses, userAnalyses) &&
            (identical(other.nextCursor, nextCursor) ||
                other.nextCursor == nextCursor));
  }

  @override
  int get hashCode => Object.hash(runtimeType,
      const DeepCollectionEquality().hash(userAnalyses), nextCursor);

  @override
  String toString() {
    return 'Karte(userAnalyses: $userAnalyses, nextCursor: $nextCursor)';
  }
}

/// @nodoc
abstract mixin class $KarteCopyWith<$Res> {
  factory $KarteCopyWith(Karte value, $Res Function(Karte) _then) =
      _$KarteCopyWithImpl;
  @useResult
  $Res call({List<UserAnalysis> userAnalyses, String? nextCursor});
}

/// @nodoc
class _$KarteCopyWithImpl<$Res> implements $KarteCopyWith<$Res> {
  _$KarteCopyWithImpl(this._self, this._then);

  final Karte _self;
  final $Res Function(Karte) _then;

  /// Create a copy of Karte
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? userAnalyses = null,
    Object? nextCursor = freezed,
  }) {
    return _then(_self.copyWith(
      userAnalyses: null == userAnalyses
          ? _self.userAnalyses
          : userAnalyses // ignore: cast_nullable_to_non_nullable
              as List<UserAnalysis>,
      nextCursor: freezed == nextCursor
          ? _self.nextCursor
          : nextCursor // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc

class _Karte implements Karte {
  const _Karte(
      {required final List<UserAnalysis> userAnalyses,
      required this.nextCursor})
      : _userAnalyses = userAnalyses;

  final List<UserAnalysis> _userAnalyses;
  @override
  List<UserAnalysis> get userAnalyses {
    if (_userAnalyses is EqualUnmodifiableListView) return _userAnalyses;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_userAnalyses);
  }

  @override
  final String? nextCursor;

  /// Create a copy of Karte
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$KarteCopyWith<_Karte> get copyWith =>
      __$KarteCopyWithImpl<_Karte>(this, _$identity);

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _Karte &&
            const DeepCollectionEquality()
                .equals(other._userAnalyses, _userAnalyses) &&
            (identical(other.nextCursor, nextCursor) ||
                other.nextCursor == nextCursor));
  }

  @override
  int get hashCode => Object.hash(runtimeType,
      const DeepCollectionEquality().hash(_userAnalyses), nextCursor);

  @override
  String toString() {
    return 'Karte(userAnalyses: $userAnalyses, nextCursor: $nextCursor)';
  }
}

/// @nodoc
abstract mixin class _$KarteCopyWith<$Res> implements $KarteCopyWith<$Res> {
  factory _$KarteCopyWith(_Karte value, $Res Function(_Karte) _then) =
      __$KarteCopyWithImpl;
  @override
  @useResult
  $Res call({List<UserAnalysis> userAnalyses, String? nextCursor});
}

/// @nodoc
class __$KarteCopyWithImpl<$Res> implements _$KarteCopyWith<$Res> {
  __$KarteCopyWithImpl(this._self, this._then);

  final _Karte _self;
  final $Res Function(_Karte) _then;

  /// Create a copy of Karte
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? userAnalyses = null,
    Object? nextCursor = freezed,
  }) {
    return _then(_Karte(
      userAnalyses: null == userAnalyses
          ? _self._userAnalyses
          : userAnalyses // ignore: cast_nullable_to_non_nullable
              as List<UserAnalysis>,
      nextCursor: freezed == nextCursor
          ? _self.nextCursor
          : nextCursor // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

// dart format on
